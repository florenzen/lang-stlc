base language definition FJ

lexical syntax
  [\ \t\r\n] -> LAYOUT

  "//" ~[\n\r]* ([\n\r] | EOF) -> LAYOUT
                               -> EOF

context-free restrictions
  LAYOUT? -/- [\ \t\r\n]
  LAYOUT? -/- [\/] . [\/]

lexical restrictions
  EOF -/- ~[]

// Identifiers
lexical syntax
  [a-zA-Z0-9]*       -> ALPHANUMS
  [a-zA-Z] ALPHANUMS -> ID {sx-atoms}

lexical restrictions
  ID -/- [a-zA-Z0-9]

// Keywords
lexical syntax
  "class"     -> Keyword
  "public"    -> Keyword
  "private"   -> Keyword
  "extends"   -> Keyword
  "void"      -> Keyword
  "super"     -> Keyword
  "return"    -> Keyword
  "null"      -> Keyword
  "new"       -> Keyword
  "extension" -> Keyword
  Keyword     -> ID {reject}

// Types
lexical syntax
  "int"         -> PrimitiveType
  "boolean"     -> PrimitiveType
  PrimitiveType -> ID {reject}

context-free syntax
  PrimitiveType -> Type
  GenClass      -> Type
  ID            -> Type
  
  ID "<" Types1 ">" -> GenClass
  
  Type            -> Types1
  Type "," Types1 -> Types1

  ID               -> TypeVars1
  ID "," TypeVars1 -> TypeVars1

// Classes
context-free syntax
  "public" "class" id:ID ClassBody                                        -> Class {sx-body-dec, sx-namespace-suffix(id)}
  "public" "class" id:ID "extends" SuperClass ClassBody                   -> Class {sx-body-dec, sx-namespace-suffix(id)}
  "public" "class" id:ID "<" TypeVars1 ">" ClassBody                      -> Class {sx-body-dec, sx-namespace-suffix(id)}
  "public" "class" id:ID "<" TypeVars1 ">" "extends" SuperClass ClassBody -> Class {sx-body-dec, sx-namespace-suffix(id)}

  GenClass -> SuperClass
  ID       -> SuperClass

  "{" Fields Constructor Methods "}" -> ClassBody
  "{" Fields Methods "}"             -> ClassBody

// Fields
context-free syntax
  "private" Type ID ";" -> Field
  
               -> Fields
  Field Fields -> Fields

// Constructors
context-free syntax
  "public" ID "(" Parameters ")" ConstructorBody -> Constructor
  
  "{" "super" "(" Exprs ")" ";" Assignments "}" -> ConstructorBody
  "{" Assignments "}"                           -> ConstructorBody

// Methods
  "public" Type ID "(" Parameters ")" MethodBody   -> Method
  "public" "void" ID "(" Parameters ")" MethodBody -> Method
  
  "{" Statements "}" -> MethodBody

                 -> Methods
  Method Methods -> Methods
  
// Parameters
context-free syntax
  Type ID -> Parameter
  
                               -> Parameters
  Parameter ParametersTail     -> Parameters
                               -> ParametersTail
  "," Parameter ParametersTail -> ParametersTail

// Statements
context-free syntax
  VarDecl                                      -> Statement
  Assignment                                   -> Statement
  MethodCall ";"                               -> Statement
  "while" "(" Expr ")" Statement               -> Statement
  "if" "(" Expr ")" Statement                  -> Statement
  "if" "(" Expr ")" Statement "else" Statement -> Statement
  "{" Statements "}"                           -> Statement
  "return" Expr ";"                            -> Statement

                       -> Statements
  Statement Statements -> Statements

// Assignments and variable declarations
context-free syntax
  VarRef "=" Expr ";" -> Assignment
  
                         -> Assignments
  Assignment Assignments -> Assignments

  Type ID "=" Expr ";" -> VarDecl
  Type ID ";"          -> VarDecl

// Method calls
context-free syntax
  Expr "." ID "(" Exprs ")" -> MethodCall
  ID "(" Exprs ")" -> MethodCall

lexical syntax
  [0-9][0-9]* -> DIGITS
  "-" DIGITS  -> INT
  "+" DIGITS  -> INT
  DIGITS      -> INT

context-free syntax
  ID            -> VarRef
  "this" "." ID -> VarRef

  INT                                   -> Expr
  "null"                                -> Expr
  VarRef                                -> Expr
  "this"                                -> Expr
  MethodCall                            -> Expr
  "new" ID "(" Exprs ")"                -> Expr
  "new" ID "<" Types1 ">" "(" Exprs ")" -> Expr
  Expr "+" Expr                         -> Expr {left}
  Expr "-" Expr                         -> Expr {left}
  Expr "*" Expr                         -> Expr {left}
  Expr "/" Expr                         -> Expr {left}
  Expr "&&" Expr                        -> Expr {left}
  Expr "||" Expr                        -> Expr {left}
  "!" Expr                              -> Expr
  Expr "<" Expr                         -> Expr {non-assoc}
  Expr "<=" Expr                        -> Expr {non-assoc}
  Expr "==" Expr                        -> Expr {non-assoc}
  Expr "!=" Expr                        -> Expr {non-assoc}
  Expr ">=" Expr                        -> Expr {non-assoc}
  Expr ">" Expr                         -> Expr {non-assoc}
  "(" Expr ")"                          -> Expr {bracket}

                     -> Exprs
  Expr ExprsTail     -> Exprs
                     -> ExprsTail
  "," Expr ExprsTail -> ExprsTail

context-free priorities
  { "!" Expr       -> Expr } >
  { Expr "*" Expr  -> Expr
    Expr "/" Expr  -> Expr } >
  { Expr "+" Expr  -> Expr 
    Expr "-" Expr  -> Expr } >
  { Expr "<" Expr  -> Expr
    Expr "<=" Expr -> Expr
    Expr ">=" Expr -> Expr
    Expr ">" Expr  -> Expr } >
  { Expr "==" Expr -> Expr 
    Expr "!=" Expr -> Expr } >
  { Expr "&&" Expr -> Expr } >
  { Expr "||" Expr -> Expr }

// Package declarations
lexical syntax
  { ID "." }+ -> PID {sx-namespace-prefixed(".")}

context-free syntax
  "package" pkg:PID ";" -> Package {sx-namespace-dec(pkg)}

// Import declarations
lexical syntax
  PID "." ID -> QID

context-free syntax
  "import" q:QID ";" -> Import {sx-import-dec(q)}

// Toplevel structure
toplevel declaration ToplevelDec
toplevel declarations ToplevelDecs

// Meta-variables
lexical syntax 
  "x" ALPHANUMS        -> MVVar
  "y" ALPHANUMS        -> MVVar
  "T" ALPHANUMS        -> MVType
  "X" ALPHANUMS        -> MVTypeVar
  "Y" ALPHANUMS        -> MVTypeVar
  "T" ALPHANUMS "+"    -> MVTypes1
  "X" ALPHANUMS "+"    -> MVTypeVars1
  "c" ALPHANUMS        -> MVClassName
  "k" ALPHANUMS        -> MVConstructorName
  "pkg" ALPHANUMS      -> MVPID
  "q" ALPHANUMS        -> MVQID
  "cbody" ALPHANUMS    -> MVClassBody
  "con" ALPHANUMS      -> MVConstructor
  "conbody" ALPHANUMS  -> MVConstructorBody
  "fld" ALPHANUMS "*"  -> MVFields
  "meth" ALPHANUMS "*" -> MVMethods
  "mbody" ALPHANUMS    -> MVMethodBody
  "p" ALPHANUMS "*"    -> MVParameters
  "p" ALPHANUMS "'"    -> MVParametersTail
  "sc" ALPHANUMS       -> MVSuperClass
  "tld" ALPHANUMS "*"  -> MVToplevelDecs

lexical restrictions
  MVVar
  MVType
  MVTypeVar
  MVClassName
  MVConstructorName
  MVPID
  MVQID
  MVClassBody
  MVConstructor
  MVConstructorBody
  MVMethodBody
  MVSuperClass
    -/- [a-zA-Z0-9]

variables
  MVVar             -> ID              {prefer}
  MVType            -> Type            {prefer}
  MVTypeVar         -> ID              {prefer}
  MVTypes1          -> Types1          {prefer}
  MVTypeVars1       -> TypeVars1       {prefer}
  MVClassName       -> ID              {prefer}
  MVConstructorName -> ID              {prefer}
  MVPID             -> PID             {prefer}
  MVQID             -> QID             {prefer}
  MVClassBody       -> ClassBody       {prefer}
  MVConstructor     -> Constructor     {prefer}  
  MVConstructorBody -> ConstructorBody {prefer}
  MVFields          -> Fields          {prefer}
  MVMethods         -> Methods         {prefer}
  MVMethodBody      -> MethodBody      {prefer}
  MVParameters      -> Parameters      {prefer}
  MVParametersTail  -> ParametersTail  {prefer}
  MVSuperClass      -> SuperClass      {prefer}
  MVToplevelDecs    -> ToplevelDecs    {prefer}

// Syntax internal to the type system
context-free syntax
  // Class signature
  "OK" -> Ok

  // Expression types
  PrimitiveType -> AType
  QID ATypes    -> AType
  ID            -> AType
  "Object"      -> AType

  "[]"              -> ATypes
  AType "::" ATypes -> ATypes

  "[]"             -> TypeVars
  ID "::" TypeVars -> TypeVars

  // Method types and signatures
  "void" -> RetType
  AType  -> RetType

  ATypes "->" RetType -> MethType

  ID ":" MethType -> MethSig
  
  "[]"                  -> MethSigs
  MethSig "::" MethSigs -> MethSigs

  // Class types
  "{" ATypes "," MethSigs "," AType "," TypeVars "}" -> ClassType

  // Imports and class table
  "[]"                      -> Imports
  ID "|->" QID "::" Imports -> Imports

  Imports                                -> ClassTable
  Imports "," ID "|->" QID ":" ClassType -> ClassTable

  // Field context
  "[]" -> FieldContext
  ID ":" AType "::" FieldContext -> FieldContext

  // Variable context
  "[]"                         -> VarContext
  ID ":" AType "::" VarContext -> VarContext

  // Method lookup result
  "undef" -> MlookupRes
  MethSig -> MlookupRes

  // Module interface
  ClassType -> ModuleInterface
  "{}"      -> ModuleInterface

lexical syntax
  "Object" -> ID {reject}

// Meta-variables
lexical syntax
  "t" ALPHANUMS       -> MVAType
  "s" ALPHANUMS       -> MVAType
  MVAType "*"         -> MVATypes
  MVTypeVar "*"       -> MVTypeVars
  "rt" ALPHANUMS      -> MVRetType
  "mt" ALPHANUMS      -> MVMethType
  "msig" ALPHANUMS    -> MVMethSig
  MVMethSig "*"       -> MVMethSigs
  "ct" ALPHANUMS      -> MVClassType
  "I" ALPHANUMS "*"   -> MVImports
  "CT" ALPHANUMS      -> MVClassTable
  "Cf" ALPHANUMS      -> MVFieldContext
  "Cv" ALPHANUMS      -> MVVarContext
  "M" ALPHANUMS       -> MVModuleInterface

lexical restrictions
  MVAType
  MVRetType
  MVMethType
  MVMethSig
  MVClassType
  MVType
  MVClassTable
  MVFieldContext
  MVVarContext
  MVModuleInterface
    -/- [a-zA-Z0-9]

variables
  MVAType           -> AType           {prefer}
  MVTypeVar         -> ID              {prefer}
  MVATypes          -> ATypes          {prefer}
  MVTypeVars        -> TypeVars        {prefer}
  MVRetType         -> RetType         {prefer}
  MVMethType        -> MethType        {prefer}
  MVMethSig         -> MethSig         {prefer}
  MVMethSigs        -> MethSigs        {prefer}
  MVClassType       -> ClassType       {prefer}
  MVImports         -> Imports         {prefer}
  MVClassTable      -> ClassTable      {prefer}
  MVFieldContext    -> FieldContext    {prefer}
  MVVarContext      -> VarContext      {prefer}
  MVModuleInterface -> ModuleInterface {prefer}

// Module system declarations
interface ModuleInterface

judgement forms
  { "suffix" "(" QID ")" "=" ID } // TODO must be provided by SoundX
  { "concat" "(" PID "," ID ")" "=" QID } // TODO must be provided by SoundX
  { ClassTable "|-" ToplevelDecs "=>" ModuleInterface }
  { ClassTable "|" PID "|-" ToplevelDecs "=>" ModuleInterface }
  { ClassTable "+" ID "|->" QID "=" ClassTable }
  { ClassTable "+" ID "|->" QID ":" ClassType "=" ClassTable }
  { ID "notin" "dom" "(" ClassTable ")" }
  { "disjoint" "(" TypeVars1 ")" "=" TypeVars }
  { ID "in" TypeVars }
  { ID "notin" TypeVars }
  { "|" TypeVars "|" "=" "|" ATypes "|" }
  { ClassTable "(" ID ")" "=" ClassType }
  { "qualify" "(" ClassTable "," ID ")" "=" QID }
  { "msigs" "(" ClassTable "," TypeVars "," AType "," ClassBody ")" "=" MethSigs } // TODO
  { "msigs" "(" ClassTable "," TypeVars "," AType "," Methods ")" "=" MethSigs } // TODO
  { ID "undef" "in" MethSigs } // TODO
  { "mlookup" "(" ClassTable "," AType "," ID ")" "=" MlookupResult } // TODO
  { "conparams" "(" ClassTable "," ID "," TypeVars "," ClassBody ")" "=" ATypes }
  { "normSuperClass" "(" ClassTable "," TypeVars "," SuperClass ")" "=" AType }
  { "normPrimParams" "(" ClassTable "," TypeVars "," Parameters ")" "=" ATypes }
  { "normPrimParamsTail" "(" ClassTable "," TypeVars "," ParametersTail ")" "=" ATypes }
  { "normPrim" "(" ClassTable "," TypeVars "," Type ")" "=" AType }
  { "normListPrim" "(" ClassTable "," TypeVars "," Types1 ")" "=" ATypes } // TODO
  { "norm" "(" ClassTable "," TypeVars "," Type ")" "=" AType }
  { "normList" "(" ClassTable "," TypeVars "," Types1 ")" "=" ATypes }
  { ClassTable "|-" ClassBody "OK" } // TODO

inductive definitions
  // Toplevel declarations
  TL-Package:
    CT | pkg |- tld* => M
    ----------------------------
    CT |- package pkg; tld* => M
  
  TLP-Import:
    suffix(q) = c
    CT + c |-> q = CT1
    CT1 | pkg |- tld* => M
    -------------------------------
    CT | pkg |- import q; tld* => M

  TLP-ClassMonObj:
    c notin dom(CT)
    msigs(CT, [], Object, cbody) = msig*
    conparams(CT, c, [], cbody) = t*
    concat(pkg, c) = q
    CT + c |-> q : {t*, msig*, Object, []} = CT1
    CT1 |- cbody OK
    -----------------------------------------------------------
    CT | pkg |- public class c cbody => {t*, msig*, Object, []}

  TLP-ClassMonSup:
    c notin dom(CT)
    normSuperClass(CT, X*, sc) = t
    msigs(CT, [], t, cbody) = msig*
    conparams(CT, c, [], cbody) = t*
    concat(pkg, c) = q
    CT + c |-> q : {t*, msig*, t, []} = CT1
    CT1 |- cbody OK
    -----------------------------------------------------------------
    CT | pkg |- public class c extends sc cbody => {t*, msig*, t, []}

  TLP-ClassGenObj:
    c notin dom(CT)
    disjoint(X+) = X*
    msigs(CT, X*, Object, cbody) = msig*
    conparams(CT, c, X*, cbody) = t*
    concat(pkg, c) = q
    CT + c |-> q : {t*, msig*, Object, X*} = CT1
    CT1 |- cbody OK
    ---------------------------------------------------------------
    CT | pkg |- public class c<X+> cbody => {t*, msig*, Object, X*}

TLP-ClassGenSup:
    c notin dom(CT)
    disjoint(X+) = X*
    normSuperClass(CT, X*, sc) = t
    msigs(CT, X*, t, cbody) = msig*
    conparams(CT, c, X*, cbody) = t*
    concat(pkg, c) = q
    CT + c |-> q : {t*, msig*, t, X*} = CT1
    CT1 |- cbody OK
    ---------------------------------------------------------------------
    CT | pkg |- public class c<X+> extends sc cbody => {t*, msig*, t, X*}

  TLP-Empty:
    -----------------
    CT | pkg |- => {}

  // Constructor parameters
  CP-Implicit:
     -----------------------------------------
     conparams(CT, c, X*, { fld* meth* }) = []

  CP-Explicit:
     normPrimParams(CT, X*, p*) = t*
     --------------------------------------------------------------
     conparams(CT, c, X*, { fld* public c(p*) conbody meth* }) = t*

  // Method signatures
  MS-ConImplicit:
  	msigs(CT, X*, t, meth*) = msig*
  	----------------------------------------
  	msigs(CT, X*, t, { fld* meth* }) = msig*

  MS-ConExplicit:
  	msigs(CT, X*, t, meth*) = msig*
  	--------------------------------------------
  	msigs(CT, X*, t, { fld* con meth* }) = msig*

  MS-Empty:
  	-----------------------
  	msigs(CT, X*, t, ) = []

  MS-Override:
  	msigs(CT, X*, t, meth*) = msig*
  	---
  	msigs(CT, X*, t, public T m(p*) mbody meth*) = msig*

  MS-NoOverride:
  	msigs(CT, X*, t, meth*) = msig*
  	---
  	msigs(CT, X*, t, public T m(p*) mbody meth*) = msig*

  MS-OverrideVoid:
  	msigs(CT, X*, t, meth*) = msig*
  	---
  	msigs(CT, X*, t, public void m(p*) mbody meth*) = msig*

  MS-NoOverrideVoid:
  	msigs(CT, X*, t, meth*) = msig*
  	---
  	msigs(CT, X*, t, public void m(p*) mbody meth*) = msig*

  // Type normalization
  // Parameters
  NPP-Empty:
    -----------------------------
    normPrimParams(CT, X*, ) = []

  NPP-NonEmpty:
    (normPrim(CT, X*, T) = t) (normPrimParamsTail(CT, X*, p') = t*)
    ---------------------------------------------------------------
    normPrimParams(CT, X*, T x p') = t :: t*

  // Class table handling
  CTI-Imports:
    ----------------------------
    I* + c |-> q = c |-> q :: I*

  CTI-ImportsClass:
    ------------------------------------------------------------
    I*, c0 |-> q0 : ct + c |-> q = c |-> q :: I*, c0 |-> q0 : ct

  CTC-Imports:
    ------------------------------------
    I* + c |-> q : ct = I*, c |-> q : ct

  CTD-Empty:
    ---------------
    c notin dom([])

  CTD-ImportsClass:
    (c =/= c0) (c notin dom(I*))
    -------------------------------
    c notin dom(I*, c0 |-> q0 : ct)

  CTD-Imports:
    (c =/= c0) (c notin dom(I*))
    ----------------------------
    c notin dom(c0 |-> q0 :: I*)

  CTL-ImportFound:
    ct = interface(q)
    -------------------
    c|->q :: I*(c) = ct

  CTL-ImportNext:
    (c0 =/= c) (I*(c) = ct)
    -----------------------
    c0|->q0 :: I*(c) = ct

  CTL-ClassFound:
    -------------------
    I*,c|->q:ct(c) = ct

  CTL-ClassNext:
    (c0 =/= c) (I*(c) = ct)
    -----------------------
    I*,c0|->q0:ct(c) = ct

  CTQ-ImportFound:
    ---------------------------
    qualify(c|->q :: I*, c) = q

  CTQ-ImportNext:
    (c0 =/= c) (qualify(I*, c) = q)
    -------------------------------
    qualify(c0|->q0 :: I*, c) = q

  CTQ-ClassFound:
    ----------------------------
    qualify(I*, c|->q:ct, c) = q

  CTQ-ClassNext:
    (c0 =/= c) (qualify(I*, c) = q)
    -------------------------------
    qualify(I*, c0|->q0:ct, c) = q

  // Type variables
  TVD-Last:
    ---------------------
    disjoint(X) = X :: []

  TVD-Cons:
    (X notin X*) (disjoint(X+) = X*)
    --------------------------------
    disjoint(X, X+) = X :: X*

  TVI-Found:
    ------------
    X in X :: X*

  TVI-Next:
    (X =/= Y) (X in X*)
    -------------------
    X in Y :: X*

  TVE-Empty:
    ----------
    X notin []

  TVE-Next:
    (X =/= Y) (X notin X*)
    ----------------------
    X notin Y :: X*

  TVL-Empty:
  	-----------
  	|[]| = |[]|

  TVL-NotEmpty:
  	|X*| = |t*|
  	-----------------
  	|X::X*| = |t::t*|
 
// Extension declarations
context-free syntax
  "public" "extension" c:ID "{" -> ExtensionBegin {sx-namespace-suffix(c)}
  "}"                           -> ExtensionEnd

extension begin ExtensionBegin 
extension end ExtensionEnd

interface for tld* is M derived by [] |- tld* => M

// File extensions
base file extension java
extensible file extension xfj
